# 6장. 키-값 저장소 설계 (NoSQL)

### 키(key)의 길이가 짧을수록 좋은 이유

- 메모리 및 저장 공간 절약
    - key는 데이터의 인덱스로 사용되므로 키의 크기가 커지면 전체 데이터의 크기도 증가한다.
- 검색 및 조회 속도 향상
    - 키-값 저장소에서 키는 해시테이블, B-트리 도는 다른 인덱싱 구조에 저장된다.
    - 키가 짧으면 해시 연산, 비교, 검색 속도가 빨라질 수 있음
    - Redis와 같은 메모리 기반 저장소에서는 CPU 캐시 효율성이 증가하여 성능이 향상된다.
- 네트워크 트래픽 절감
    - 분산 시스템(Redis 클러스터, DynamoDB 등)에서는 키와 값을 네트워크를 통해 전송해야한다.
    - 키가 길면 네트워크 대역폭을 더 많이 차지하게 되어 성능이 저하될 수 있다.
    - 고빈도 조회 요청이 많은 시스템에서는 짧은 키를 사용하면 네트워크 부하를 줄일 수 있다.
- 하지만 너무 짧은 키는 가독성이 저하될 수 있고, 해시 충돌 위험이 증가한다.

## 단일 서버 키-값 저장소

가장 직관적인 방법 :  키-값 쌍 전부를 메모리에 해시 테이블로 저장

- 단점
    - 모든 데이터를 메모리 안에 두는 것이 불가능할 수도 있다.
- 해결책
    - 데이터 압축
    - 자주 쓰이는 데이터만 메모리에 두고 나머지는 디스크에 저장
        - Mysql + Redis 조합
- 분산 키-값 저장소

## 분산 키-값 저장소

### CAP 정리 (Consistency, Availability, Partition Tolerance theorem)

CAP 정리는 일관성(Consisency), 가용성 (Availability), 파티선 감내(Partition Tolerance)라는 세 가지 요구사항을 동시에 만족하는 분산 시스템을 설계하는 것은 불가능하다는 정리.

- 데이터 일관성 : 분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐에 관계없이 언제나 같은 데이터를 보게 되어야 한다.
- 가용성 : 분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생하더라도 항상 응답을 받을 수 있어야 한다.
- 파티선 감내 : 파티션은 두 노드 사이에 통신 장애가 발생하였음을 의미한다. 파티션 감내는 네트워크에 파티션이 생기더라도 시스템은 계속 동작하여야 한다는 것을 뜻한다.

CAP 정리는, 이들 가운데 두 가지를 충족하려면 나머지 하나는 반드시 희생되어야 한다는 것을 의미한다.

따라서, 키 값 저장소는 앞서 제시한 세 가지 요구사항 가운데 어느 두 가지를 만족하느냐에 따라 다음과 같이 분류할 수 있다.

- CP 시스템 : 일관성과 파티션 감내를 지원하는 키-값 저장소. 가용성을 희생한다.
- AP 시스템 : 가용성과 파티션 감내를 지원하는 키-값 저장소. 데이터 일관성을 희생한다.

### 실세계의 분산 시스템

분산 시스템은 파티션 문제를 피할 수 없다.

파티션 문제가 발생하면 일관성과 가용성 사이에서 하나를 선택해야 한다.

- 은행의 경우 : 데이터 일관성이 중요하기에 가용성을 포기한다.
    - 온라인 뱅킹 시스템이 계좌 최신 정보를 출력하지 못한다면 큰 문제가 발생한다. 따라서 네트워크 파티션 때문에 일관성이 깨질 상황이 발생하면 이런 시스템은 상황이 해결될 때까지는 오류를 반환해야한다.
- 소셜 미디어(SNS) : 가용성이 중요하기에 데이터 일관성을 포기한다.
    - 일부 최신 게시물이 늦게 동기화되더라도 서비스가 멈추면 안된다. 다라서 네트워크 문제가 발생하더라도, 기존 데이터라도 보여주는 것이 중요하다.

### 시스템 컴포넌트

키-값 저장소 구현에 사용될 핵심 컴포넌트 및 기술들

- 데이터 파티션
- 데이터 다중화
- 일관성
- 일관성 불일치 해서
- 장애 처리
- 시스템 아키텍처 다이어그램
- 쓰기 경로
- 읽기 경로

컴포넌트 : 시스템을 구성하는 독립적인 모듈(부분). 특정한 기능을 수행하는 요소를 의미한다.

즉, 키-값 저장소를 개발할 대 필요한 컴포넌트 : 데이터 저장 컴포넌트, 검색 컴포넌트, 네트워크 통신 컴포넌트, 캐싱 컴포넌트 등

### 데이터 파티션

대규모 애플리케이션의 경우 전체 데이터를 한 대의 서버에 욱여넣는 것은 불가능하다.

따라서 데이터를 작은 파티션들로 분할한 다음 여러 대의 서버에 저장해야한다.

데이터를 파티션 단위로 나눌 때 안정해시를 사용하면 아래의 두 가지 문제를 해결할 수 있다.

- 데이터를 여러 서버에 고르게 분산할 수 있는지
- 노드가 추가되거나 삭제될 때 데이터의 이동을 최소화할 수 있는지

안정해시를 사용하여 데이터를 파티션할 때의 장점

- 규모 확장 자동화 : 시스템 부하에 따라 서버가 자동으로 추가되거나 삭제되도록 만들 수 있다.
- 다양성 : 각 서버의 용량에 맞게 가상 노드의 수를 조정할 수 있다.

### 데이터 다중화

높은 가용성과 안정성을 확보하기 위해서는 데이터를 N개 서버에 비동기적으로 다중화할 필요가 잇다.

즉, 특정 노드의 서버가 죽어도 그 뒤의 n개의 서버에 데이터를 저장해놨다면 계속해서 안정적으로 서비스가 가능하다.

### 데이터 일관성

여러 노드에 다중화된 데이터는 적절히 동기화가 되어야 한다. 정족수 합의 프로토콜을 사용하면 읽기/쓰기 연산 모두에 일관성을 보장할 수 있다.

- 정족수 합의 프로토콜 : 시스템 내에서 데이터에 대한 읽기 및 쓰기 연산을 수행할 때, 특정 수의 노드(정족수)가 연산에 참여하고 동의해야 작업이 성공하는 방식
    - N = 사본 개수
    - W = 쓰기 연산에 대한 정족수. 쓰기 연산이 성공한 것으로 간주되려면 적어도 W개의 서버로부터 쓰기 연산이 성공했다는 응답을 받아야 한다.
    - R = 읽기 연산에 대한 정족수. 읽기 연산이 성공한 것으로 간주되려면 적어도 R개의 서버로부터 응답을 받아야 한다.

- R = 1, W = N  → 빠른 읽기 연산에 최적화된 시스템
- W = 1, R = N → 빠른 쓰기 연산에 최적화된 시스템
- W + R > N  → 강한 일관성이 보장됨 ( 보통 N = 3, W = R = 2)
- W + R ≤ N → 강한 일관성이 보장되지 않음

**비 일관성 해소 기법 : 데이터 버저닝**

데이터에 버전에 대한 정보를 추가하여, 저장소1에는 해당 정보가 업데이트 되었지만, 저장소2에는 해당 정보가 업데이트 되지 않았을 때, 저장소1과 저장소2 중 어떤 정보가 최신의 정보인지를 판별하여 정보를 최종적으로 업데이트할 지를 결정할 수 있다.

### 장애 감지

가십 프로토콜 같은 분산형 장애감지 솔루션을 통해 장애를 감지한다.

가십 프로토콜의 동작 원리

- 각 노드는 멤버십 목록(membership list)를 유지한다. 멤버십 목록은 각 멤버 ID와 박동 카운터(hertbeat counter) 쌍의 목록이다.
- 각 노드는 주기적으로 자신으 ㅣ박동 카운터를 증가시킨다.
- 각 노드는 무작위로 선정된 노드들에게 주기적으로 자기 박동 카운터 목록을 보낸다.
- 박동 카운터 목록을 받은 노드는 멤버십 목록을 최신 값으로 갱신한다.
- 어던 멤버의 박동 카운터 값이 지정된 시간 동안 갱신되지 않으면 해당 멤버는 장애 상태인 것으로 간주한다.

일시적 장애처리 / 영구 장애 처리

**영구 장애처리**

영구 장애는 단순한 네트워크 오류가 아니라 노드가 완전히 사라지는 문제.

이때, 데이터를 복구하기 위해 반-엔트로피(anti-entropy) 프로토콜을 사용한다.

- 반 엔트로피 프로토콜
  - 여러 노드에 저장된 데이터를 비교해서 최신 버전으로 동기화하는 것
  - 이를 위해 머클트리(Merkle Tree)를 사용한다.
- 머클 트리
  - 해시 트리의 일종. 데이터의 변화를 효율적으로 감지하는 트리 구조
  - 서버간에 머클 트리의 루트 해시값만 비교하면 데이터가 동일하지, 차이가 있는지 빠르게 알 수 있다.
  - 해싱한 결과를 또 해싱하고 또 해싱하며 트리구조를 완성시키고, 최종적으로는 루트 해시값만 확인하여 데이터의 변경 여부를 빠르게 알 수 있는 것.