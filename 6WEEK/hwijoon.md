# 9장. 웹 크롤러 설계

웹 크롤러는 검색 엔진에서 널리 쓰는 기술로, 웹에 새로 올라오거나 갱신된 콘텐츠를 찾아내는 것이 주된 목적이다.

- 콘텐츠 : 웹 페이지, 이미지, 비디오, pdf 등

웹 크롤러는 몇 개 웹 페이지에서 시작하여 그 링크를 따라 나가면서 새로운 콘텐츠를 수집한다.

- 검색 엔진 인덱싱 : 크롤러의 가장 보편적인 옹례. 크롤러는 웹 페이지를 모아 검색 엔진을 위한 로컬 인덱스를 만든다.
    - Googlebot : 구글 검색 엔진이 사용하는 웹 크롤러
- 웹 아카이빙 : 나중에 사용할 목적으로 장기보관하기 위해 웹에서 정보를 모으는 절차를 말한다. 많은 국립 도서관이 크롤러를 돌려 웹 사이트를 아카이빙한다.
- 웹 마이닝 : 크롤러를 이용해 웹에서 데이터를 수집하고, 이를 분석하여 의미 있는 정보를 추출하는 과정이다.
- 웹 모니터링 : 크롤러를 사용하면 인터넷에서 저작권이나 상표권이 침해되는 사례를 모니터링할 수 있다.

## 1단계 : 문제 이해 및 설계 범위 확정

좋은 웹 크롤러가 만족시켜야 할 속성

- 규모 확장성 : 웹은 거대하다. 오늘날 웹에는 수십억 개의 페이지가 존재한다. 따라서 병행성을 활용하면 보다 효과적으로 웹 크롤링을 할 수 있다.
- 안정성 : 웹은 함정으로 가득하다. 잘못 작성된 HTML, 아무 반응이 없는 서버, 장애, 악성 코드가 붙어있는 링크 등이 그 예이다. 크롤러는 이런 비정상적 입력이나 환경에 잘 대응할 수 있어야한다.
- 예절 : 크롤러는 수집 대상 웹 사이트에 짧은 시간 동안 너무 많은 요청을 보내서는 안된다.
- 확장성 :새로운 형태의 콘텐츠를 지원하기가 쉬워야 한다. 예를 들어, 이미지 파일도 크롤링하는 기능을 추가할 때 전체 시스템을 새로 설계해야하면 곤란하다.

개략적 규모 추정

- 매달 10억 개의 웹 페이지를 다운로드한다.
- QPS = 10억 / 30일 / 24시간 / 3600초 = 대략 400페이지/초
- 최대(Peak) QPS = 2 * QPS = 800
- 웹 페이지의 크기 평균은 500k라고 가정한다.
- 10억 페이지 * 500k = 500TB/월.
- 1개월치 데이터를 보관하는 데는 500TB, 5년관 보관한다고 가정하면 500TB * 12개월 * 5년 = 30PB의 저장용량이 필요하다.

## 2단계 : 개략적 설계안 제시 및 동의 구하기

### 시작 url 집합

웹 크롤러가 크롤링을 시작하는 출발점.

예를 들면, 어떤 대학 웹사이트로부터 찾아 나갈 수 있는 모든 웹 페이지를 크롤링하는 가장 직관적인 방법은 해당 대학의 도메인 이름이 붙은 모든 페이지의 URL을 시작 URL로 쓰는 것이다.

일반적으로는 전체 URL 공간을 작은 부분집합으로 나누는 전략을 쓴다.

### 미수집 URL 저장소

대부분의 현대적 웹 크롤러는 크롤링 상태를

(1) 다운로드할 URL

(2) 다운로드된 URL

두 가지로 나눠 관리한다.

이 중 ‘다운로드할 URL’을 저장 관리하는 컴포넌트를 미수집 URL(URL frontier)라고 부른다. (=Queue 라고 생각)

### HTML 다운로더

인터넷에서 웹 페이지를 다운로드하는 컴포넌트. 다운로드할 페이지의 URL 은 미수집 URL 저장소가 제공한다.

### 도메인 이름 변환기

웹 페이지를 다운받으려면 URL을 IP 주소로 변환하는 절차가 필요하다. HTML 다운로더는 도메인 이름 변환기를 사용하여 URL 주소에 대응되는 IP 주소를 알아낸다.

### 콘텐츠 파서

이상한 웹 페이지는 문제를 일으킬 수 있고, 저장 공간만 낭비하기 때문에 웹 페이지를 다운로드하면 파싱과 검증 절차를 거쳐야한다.

### 중복 컨텐츠인가?

중복 컨텐츠인지 비교하기 위해 전체 문자열을 비교하는 것이 아니라 웹페이지의 해시 값을 비교하는 방식을 사용한다.

### 콘텐츠 저장소

콘텐츠 저장소는 HTML 문서를 보관하는 시스템이다. 저장소를 구현하는 데 쓰일 기술을 고를 대는 저장할 데이터의 유형, 크기 ,저장소 접근 빈도, 데이터의 유효 기간 등을 종합적으로 고려해야 한다. 본 설계얀의 경우에는 디스크와 메모리를 동시에 사용하는 저장소를 택한다.

- 데이터의 양이 너무 많으므로 대부분의 콘텐츠는 디스크에 저장한다.
- 인기 있는 콘텐츠는 메모리에 두어 접근 지연시간을 줄인다.

### URL 추출기

URL 추출기는 HTML 페이지를 파싱하여 링크들을 골라내는 역할을 한다.

<li><a href=”https://www.naver.com”>naver</a></li>

에서

https://www.naver.com 를 추출한다.

- 상대경로는 추출한 뒤 절대경로로 변환한다.

### URL 필터

URL 필터는 특정한 콘텐츠 타입이나 파일 확장자를 갖는 URL, 접속 시 오류가 발생하는 URL, 접근 제와 목록에 포함된 URL 등을 크롤링 대상에서 배제하는 역할을 한다.

### 이미 방문한 URL?

블룸 필터나 해시 테이블을 이용해서 이미 방문한 적이 있는 URL인지 추척한다.

### URL 저장소

이미 방문한 URL을 보관하는 저장소

## 3단계 상세 설계

### DFS를 쓸 것인가, BFS를 쓸 것인가

웹은 유향 그래프와 같다. DFS를 쓰면 어느정도로 깊게 들어갈 지 가늠할 수 없기 때문에 주로 BFS를 사용한다.

- BFS를 사용할 때 단순히 fifo 큐를 사용하면 생기는 두 가지 문제점
    1. 한 페이지에서 나오는 링크의 상당수는 같은 서버로 되돌아간다.
        - 이러면 같은 호스트에 속한 많은 링크를 다운받느라 바빠지게 되는데, 링크들을 병렬로 처리하게 된다면 해당 페이지의 서버는 수많은 요청으로 과부하에 걸리게 된다. 이런 크롤러는 예의없는 크롤러로 간주된다.
    2. URL간에 우선순위를 두지 않는다.
        - 표준적 BFS 알고리즘은 URL 간에 우선순위를 두지 않는다. 모든 웹페이지가 같은 수줄의 품질, 같은 수준의 중요성을 갖지 않기 때문에 페이지 순위, 사용자 트래픽의 양, 업데이트 빈도 등 여러가지 척도에 비추어 처리 우선순위를 구별해야한다.

### 미수집 URL 저장소

웹 크롤러는 URL을 수집하고 다운로드하는 과정에서 효율적인 URL 저장소가 필요하다. 이 저장소를 잘 설계하면 크롤러의 예의(politeness), URL 간의 우선순위 설정, 데이터 신선도(freshness) 등을 적절히 관리할 수 있다.

미수집 URL 저장소의 동작 원리

- 웹 크롤러는 너무 많은 요청을 보내는 것을 피해야 한다. 이는 서버 과부하 및 DoS(서비스 거부) 공격으로 오인될 가능성이 있기 때문이다.
- 동일한 웹사이트에서 여러 페이지를 요청할 때는 일정한 시간 간격을 두고 다운로드하는 방식이 바람직하다.
- 크롤러는 호스트명(hostname)과 다운로드 작업 스레드(worker thread) 간의 관계를 유지해야 한다. 즉, 같은 사이트에 대한 요청을 하나의 FIFO 큐에서 관리하여 트래픽을 조절하는 방식이 필요하다.

미수집 URL 저장소의 주요 설계 요소

1. 큐 라우터(queue router)
    - 동일한 호스트에 속하는 URL이 항상 같은 큐(b1, b2, ..., bn)로 들어가도록 함.
2. 매핑 테이블(mapping table)
    - 호스트명과 큐 간의 관계를 저장하는 테이블.
3. FIFO 큐
    - 동일한 호스트의 URL을 관리하며, 요청이 순차적으로 처리되도록 보장.

### 문제 있는 콘텐츠 감지 및 회피

웹 크롤링 시 중복 콘텐츠, 거미 덫(spider trap), 데이터 노이즈와 같은 문제가 발생할 수 있다. 이를 감지하고 회피하는 방법이 필요하다.

1) 중복 콘텐츠

- 웹 콘텐츠의 약 30%가 중복된 페이지로 구성되어 있다.
- 해시 체크섬(checksum) 기법을 사용하면 중복된 콘텐츠를 효과적으로 탐지할 수 있다.

2) 거미 덫(spider trap)

- 크롤러가 무한 루프에 빠지게 만드는 특정 URL 구조가 존재할 수 있다.
  예: `spidertrapexample.com/foo/bar/foo/bar/foo/bar/...`
- 해결 방법:
    - URL의 최대 길이 제한: 너무 긴 URL은 필터링.
    - 알고리즘적 탐지: 봇을 자동으로 피하는 사이트를 판별하는 알고리즘 적용.
    - 수작업 확인 후 제외: 관리자가 직접 문제 사이트를 탐지 후 크롤러의 탐색 대상에서 제외.

3) 데이터 노이즈

- 광고, 스팸, 무의미한 페이지는 크롤링할 필요가 없다.
- 스팸 필터링을 통해 무가치한 콘텐츠를 사전에 걸러내는 것이 중요하다.

### 크롤러의 성능 최적화

1) 도메인 이름 변환 결과 캐시

- 크롤링 성능의 병목 중 하나는 DNS 조회 요청이다.
- DNS 조회가 완료될 때까지 다른 작업을 진행할 수 없기 때문에 이름-IP 주소 매핑을 캐싱하여 성능을 향상시킬 수 있다.

2) 지역성(locality) 활용

- 크롤링 서버를 지역적으로 분산 배치하면 다운로드 속도를 최적화할 수 있다.
- 크롤링 대상 서버와 가까운 데이터센터에서 크롤링을 수행하면 네트워크 성능이 향상된다.

3) 짧은 타임아웃 설정

- 크롤링 중 응답이 느린 서버가 있으면 해당 요청을 무한정 기다리는 것이 비효율적이다.
- 최대 대기 시간을 설정하여 응답이 없을 경우 다음 페이지로 넘어간다.

4) 안정성 향상

- 안정 해시(consistent hashing)
    - 다운로드 서버의 부하를 분산하는 기법.
- 서버 측 렌더링(server-side rendering)
    - 많은 웹사이트가 JavaScript 및 AJAX를 사용하기 때문에, 크롤러는 정적인 HTML이 아닌 동적으로 렌더링된 결과를 가져올 필요가 있음.
    - 서버 측 렌더링(dynamic rendering)을 적용하면 크롤러가 JavaScript 기반 페이지도 제대로 크롤링할 수 있음.

### 크롤러의 설계 및 관리

1) 크롤러의 예외 처리

- 크롤링 중 에러 발생은 불가피하므로, 시스템 전체가 중단되지 않도록 설계해야 함.
- 장애 발생 시 데이터를 로그에 저장하여 복구할 수 있어야 함.

2) 데이터 검증(data validation)

- 크롤러가 가져온 데이터의 무결성 검사가 필요함.
- 잘못된 데이터를 감지하여 제외하는 것이 중요함.

3) 지속적인 URL 저장

- 모든 URL을 메모리에 저장하는 것은 비효율적이므로, 하이브리드 저장 방식을 사용.
    - 일부는 디스크, 일부는 메모리에서 관리.
    - 메모리 버퍼 큐를 두어 성능을 최적화함.