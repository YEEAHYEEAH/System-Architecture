# 7장. 분산 시스템을 위한 유일 ID 생성기 설계

데이터베이스 서버를 여러개 사용할 경우, auto_increment로는 유일한 ID값을 보장할 수 없다.

## 유일성이 보장되는 ID를 만드는 방법

- 다중 마스터 복제(multi-master replication)
- UUID(Universally Unique Identifier)
- 티켓 서버(ticket server)
- 트위터 스노플레이크(twitter snowflake) 접근법

## 다중 마스터 복제

하나의 서버는 1,3,5,,, 홀수 id 만 생성

다른 서버는 2,4,6,,, 짝수 id만 생성

단점

- 시간의 흐름에 따라 ID값이 커지기는 하지만, 정확한 시간 흐름에 따른 정렬은 보장되지 않는다.
- 새로운 서버를 추가하거나, 기존 서버를 삭제할 때 시스템이 정상적으로 작동하도록 유지하기 어렵다.

## UUID

전 세계에서 고유한 식별자를 생성하기 위한 표준화된 방법.

- 128비트(16바이트) 크기의 숫자로 표현되며, 일반적으로 36자의 문자열 형태로 사용된다.

### **UUID의 버전**

UUID는 다양한 용도에 맞게 여러 가지 버전으로 제공됩니다.

1. **Version 1 (시간 기반)**
    - 시간과 호스트 시스템의 네트워크 MAC 주소를 이용해 생성됩니다.
    - 네트워크 카드의 MAC 주소를 사용하기 때문에 보안 문제가 있을 수 있습니다.
    - 예: `a42e3b60-0b9b-11e5-a6c0-1697f925ec7b`
2. **Version 2 (DCE 보안)**
    - 버전 1과 유사하지만, POSIX UID/GID 정보를 포함할 수 있습니다.
    - 거의 사용되지 않습니다.
3. **Version 3 (이름 기반, MD5 해시)**
    - 네임스페이스와 이름을 결합해 MD5 해시를 사용하여 생성됩니다.
    - 동일한 이름에 대해 항상 동일한 UUID가 생성됩니다.
    - 예: `f47ac10b-58cc-3372-a567-0e02b2c3d479`
4. **Version 4 (난수 기반)**
    - 완전히 무작위(랜덤) 또는 의사난수를 이용하여 생성됩니다.
    - 가장 많이 사용되는 유형으로, 보안과 성능이 균형을 이룹니다.
    - 예: `c9bf9e57-1685-4c89-bafb-ff5af830be8a`
5. **Version 5 (이름 기반, SHA-1 해시)**
    - 버전 3과 유사하지만, 해시 알고리즘으로 SHA-1을 사용합니다.
    - 예: `2c0f1fc0-d3d6-5c7a-85b6-6b7d6b5e6347`

### 🚀 **UUID 사용 사례**

- **데이터베이스 키:** 분산 시스템에서 중복 없이 고유한 키를 생성할 때 사용됩니다.
- **파일 및 리소스 식별자:** 대규모 시스템에서 파일, 이미지, 세션 등의 식별자로 사용됩니다.
- **API 및 메시지 큐:** 고유한 트랜잭션 ID 또는 메시지 ID 생성에 사용됩니다.

### 장점

- UUID를 쉽게 만들 수 있다.
- 서버 사이의 조율이 필요 없으므로 동기화 이슈도 없다.
- 각 서버가 자기가 쓸 ID를 알아서 만드는 구조이므로 규모 확장이 쉽다.

### 단점

- ID가 128비트로 길다.
- ID를 시간순으로 정렬할 수 없다.
- ID에 숫자가 아닌 값이 포함될 수 있다.

## 티켓 서버

중앙 집중식 서버(Ticket Server)가 ID를 생성하고, 다른 서버들은 이 티켓 서버에 ID를 요청하여 고유성을 보장하는 방식.

### 티켓 서버 방식의 작동 원리

1. 중앙 티켓 서버 배포
- 하나의 티켓 서버를 설정
- 티켓 서버는 고유 ID를 생성하고 관리하는 역할을 수행한다.
1. ID 생성 요청
    - 애플리케이션 서버 또는 서비스가 고유 ID가 필요할 때마다 티켓 서버에 요청을 보낸다.
2. ID 할당
    - 티켓 서버는 ID를 생성하여 요청한 서버에 반환한다.
    - ID는 자동 증가 값(Auto-Increment), UUID, 시간 기반 ID(Time-based ID) 등 다양한 방식으로 생성할 수 있다.
3. 사용 및 저장
    - ID를 받은 서버는 이 ID를 데이터베이스에 저장하거나 필요한 로직에 활용한다.

### Auto-Increment 방식

- 장점 : ID가 순차적이므로 정렬과 인덱싱에 유리하다.
- 단점 : 티켓 서버의 부하가 커지면 병목이 발생할 수 있다.

### ID 블록 배정 방식

티켓 서버가 ID의 범위(Block)를 각 애플리케이션 서버에 할당하는 방식.

서버는 할당받은 ID 범위 내에서 로컬에서 ID를 생성하므로 티켓 서버에 매번 요청할 필요가 없다.

- 장점 : 성능이 뛰어나고 티켓 서버 부하를 줄일 수 있다.
- 단점 : ID 범위를 다 소진하면 다시 요청해야 한다.

## 트위터 스노플레이크 접근법 (Twitter snowflake)

twitter에서 개발한 분산 시스템용 고유 id 생성 알고리즘.

각각의 서버에서 독립적으로 생성된다. 중앙 서버를 사용하지 않기 때문에 분산 시스템에서 매우 효율적으로 작동한다.

**스노우플레이크 id 구조**

| 비트 수 | 구성 요소 | 설명 |
| --- | --- | --- |
| 1비트 | **사인 비트(Sign bit)** | 항상 0으로 고정 (양수 ID만 생성) |
| 41비트 | **타임스탬프(Timestamp)** | 밀리초 단위 시간 (Twitter Epoch 이후) |
| 5비트 | **데이터센터 ID(Data Center ID)** | 최대 32개 데이터센터 식별 가능 |
| 5비트 | **서버 ID(Worker ID)** | 데이터센터당 최대 32개 서버 식별 가능 |
| 12비트 | **일련번호(Sequence Number)** | 동일 밀리초 내 최대 4096개의 ID 생성 |

### **각 필드의 역할**

1. **사인 비트 (1비트)**:
    - 항상 `0`으로 설정.
    - 양의 정수만 생성할 수 있게 함.
2. **타임스탬프 (41비트)**:
    - 밀리초 단위로 현재 시간 저장.
    - **Twitter Epoch** (1288834974657, 2010년 11월 4일 01:42:54 UTC) 이후의 경과 시간을 사용.
    - 최대 약 **69년** 동안 사용할 수 있는 시간 범위를 제공.
3. **데이터센터 ID (5비트)**:
    - 최대 **32개(2^5)**의 데이터센터를 지원.
    - 분산 환경에서 데이터센터를 식별하는 데 사용.
4. **서버 ID (5비트)**:
    - 각 데이터센터 내에서 최대 **32개(2^5)**의 서버를 식별.
    - 서버 간의 ID 충돌을 방지.
5. **일련번호 (12비트)**:
    - 동일한 밀리초 내에서 생성되는 ID의 **순번**을 부여.
    - 최대 **4096개(2^12)**의 ID를 1밀리초 내에 생성 가능.
    - 밀리초가 바뀔 때마다 초기화(`0`으로 리셋).

### **스노우플레이크의 작동 원리**

1. **타임스탬프 생성**:
    - 현재 시간을 Twitter Epoch로부터의 밀리초 값으로 변환.
2. **데이터센터 및 서버 ID 설정**:
    - 시스템이 시작될 때 고정값으로 설정되며, 운영 중에는 변경되지 않음.
3. **일련번호 증가**:
    - 동일 밀리초 내에서 ID를 요청할 때마다 일련번호가 증가.
    - 일련번호가 4096에 도달하면 **다음 밀리초까지 대기**.
4. **ID 생성 및 반환**:
    - 각 비트를 **Bitwise Shift** 및 **OR 연산**을 통해 하나의 64비트 정수로 결합.
    - 최종 ID는 **시간순 정렬이 가능**하며, 고유성이 보장됩니다.

### **스노우플레이크 알고리즘의 장점**

1. **고유 ID 보장 (Uniqueness)**:
    - 타임스탬프 + 데이터센터 ID + 서버 ID + 일련번호 조합으로 충돌 가능성 거의 없음.
2. **시간 정렬 가능 (Sortable ID)**:
    - 타임스탬프가 가장 앞에 있어, 생성된 ID는 **시간 순서대로 정렬** 가능.
    - 데이터베이스에서 **인덱싱 성능**이 좋음.
3. **고성능 및 확장성 (Performance & Scalability)**:
    - 분산 환경에서 독립적으로 ID 생성 가능.
    - 데이터센터 및 서버를 추가하여 쉽게 확장 가능.

### **스노우플레이크 알고리즘의 단점 및 고려 사항**

1. **시스템 시간 동기화 문제**:
    - 모든 서버의 시스템 시간이 **동기화(NTP)** 되어야 함.
    - 시간이 되돌아가는 경우(ID 충돌 위험) 방지 로직 필요.
2. **데이터센터 및 서버 ID 관리**:
    - 데이터센터 ID와 서버 ID가 **중복되지 않도록 관리** 필요.
    - 잘못된 설정 시 ID 충돌이 발생할 수 있음.
3. **밀리초 단위의 ID 생성량 제한**:
    - 1밀리초에 **4096개 이상**의 ID 생성이 필요하면 대기 시간이 발생.
    - 대기 시간을 줄이기 위해 **여러 서버를 사용하거나** 알고리즘을 튜닝해야 함.

### 타임 스탬프

- 타임스탬프를 사용하면 생성된 ID가 시간 순서대로 정렬될 수 있다.
- 41비트로 표현할 수 있는 최대값은 2^41 - 1로, 약 69년 동안의 시간을 나타낼 수 있다.

타임 스탬프 변환 예시

1. 바이너리 값 : 타임스탬프는 이진수로 저장된다.
2. 10진수 변환 : 2진수를 10진수로 변환하면 297616116568이 된다.
3. 기준 시간 추가 : Epoch 시간은 스노우플레이크 알고리즘에서 타임스탬프를 계산할 때 기준이 되는 시작 시간을 의미한다. 1970년 1월 1일 00:00:00 UTC(유닉스 시간의 시작)와는 다르게, 트위터의 스노우플레이크 알고리즘에서는 2010년 11월 4일 01:42:54 UTC를 Epoch 시간으로 사용한다.
    - 트위터가 스노우플레이크 ID 시스템을 도입한 시점에 맞추어 설정된 것.

### 시계 동기화(Clock Synchronization)

분산 시스템에서 여러 서버나 장치의 시스템 시간이 동일하게 유지되도록 만드는 과정.

스노우플레이크 알고리즘과 같은 분산 ID 생성 시스템에서는 시계 동기화가 매우 중요하다.

**시계 동기화의 필요성**

1. **ID의 고유성 유지:**
    - 스노우플레이크 ID 생성 시 타임스탬프를 사용하기 때문에 서버 간 시간이 다르면 ID 충돌이 발생할 수 있습니다.
    - 예를 들어, 한 서버의 시간이 뒤로 설정되어 있으면 기존에 생성된 ID보다 작은 값의 ID가 생성될 수 있습니다.
2. **정렬 가능성 유지:**
    - ID가 시간순으로 정렬될 때 서버 간 시간 차이가 있으면 정렬이 깨질 수 있습니다.
    - 데이터 저장이나 로그 분석 시 시간 순서가 어긋나게 되어 시스템의 신뢰성이 저하됩니다.
3. **데이터 일관성:**
    - 분산 데이터베이스나 캐시 시스템(Redis, Kafka 등)에서 시간 차이에 의해 데이터가 불일치할 수 있습니다.

### NTP

서버를 여러 대 사용하면 각 서버의 시간이 미세하게 다를 수 있다.

- 서버 A : 10:00:00.100
- 서버 B : 10:00:00:200
- 서버 C : 10:00:00:150

NTP 작동 방식

1. 모든 서버에 동일한 NTP 서버를 설정한다.

    ```jsx
    # 모든 서버의 ntp.conf 설정 예시
    server time1.google.com iburst
    server time2.google.com iburst
    server time3.google.com iburst
    server time4.google.com iburst
    server pool.ntp.org iburst
    ```

2. 시간 서버의 신뢰도 평가
    - NTP는 각 서버의 오프셋과 지터를 계산하고, 시간이 가장정확하고 안정적인 서버를 선택한다.
        - 오프셋(Offset) : 현재 서버 시간과 서버 시간의 차이
        - 지터(Jitter) : 응답 시간의 변동성
3. 쿼럼 메커니즘
    - NTP는 적어도 3개 이상의 시간 서버의 시간을 비교해, “다수결” 방식으로 가장 적절한 시간을 선택한다.
    - 5개의 시간 서버가 있다면, 가장 극단적인 값 2개(최대값, 최소값)을 버리고 중간값을 채택한다.
    - 이를 통해 오작동하거나 오류가 있는 시간 서버의 영향을 줄인다.
4. 시간 조정
    - NTP는 서버간의 시간 차이를 두 가지 방법으로 맞춘다.(128ms 이상 차이나면 step방식, 그보다 적으면 slew 방식 사용)
    - Slew(서서히 조정)
        - 시간이 약간 어긋났을 때 사용
        - 시계를 조금씩 빨리 또는 느리게 돌려 서서히 맞춘다.
    - Step(즉시 조정)
        - 시간이 크게 차이날 때 사용
        - 시간을 즉시 점프시켜 맞춘다.
5. 주기적인 재동기화
    - NTP는 주기적으로 시간 서버와 동기화함으로서 시간이 서서히 다시 어긋나는 drift 현상을 방지한다.

**요약**

즉, db, was, redis 각 서버는 별도로 설정한 NTP 서버들로부터 시간을 받아와서 가장 정확한 시간을 선택하여 자신의 시간을 slew 또는 step 방식으로 맞춰나갑니다.