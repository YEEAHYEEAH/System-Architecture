### 분산 환경에서 auto increment 속성 접근법이 통하지 않는 이유

- DB 서버 한대로는 그 요구를 감당할 수 없고, 여러 데이터베이스 서버를 쓰는 경우 지연 시간을 낮추기가 무척 힘들기때문

### 유일 ID 생성기 요구사항

1. ID는 유일해야함
2. ID는 숫자로만 구성되어야함
3. ID는 64비트로 표현될 수 있는 값이어야함
4. ID는 발급 날짜에 따라 정렬 가능해야함
5. 초당 10,000개의 ID를 만들 수 있어야함

## 유일성이 보장되는 ID 설계 방법

### 1. 다중 마스터 복제

- DB의 auto increment 기능을 활용하지만, 다음ID값을 구할때 1만큼 증가시키는 것이 아니라 현재 사용중인 데이터베이스 서버수만큼 증가시키는 방법
- 단점
    - 여러 데이터 센터에 걸쳐 규모를 늘리기 어려움
    - ID 유일성은 보장되지만 시간흐름에 맞춰 커지도록 보장할수는 없음
    - 서버를 추가하거나 삭제할때도 잘 동작하도록 만들기 어려움

### 2. UUID

- 유일성이 보장되는 ID를 만드는 간단한 방법
- 컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트짜리 수
- UUID값은 충돌 가능성이 지극히 낮음
- 동기화 이슈도 없음
- 규모 확장도 쉬움
- 단점
    - ID가 128비트로 길지만, 서버에서 요구하는 길이는 64비트
    - ID를 시간순으로 정렬할 수 없음
    - ID에 숫자가 아닌 값이 포함될 수 있음

### 3. 티켓 서버

- auto increment 기능을 갖춘 데이터베이스 서버, 즉 티켓 서버를 중앙집중형으로 하나만 사용하는 것
- 유일성이 보장되는 오직 숫자로만 구성된 ID를 쉽게 만들 수 있음
- 구현하기 쉽고 중소 규모 애플리케이션에 적합함
- 단점
    - 티켓 서버가 SPOF됨.
    - 티켓 서버에 장애가 발생하면 해당 서버를 이용하는 모든 시스템이 영향을 받음
    - 티켓 서버를 여러대 준비하면 해결할 수 있지만, 동기화 문제가 새로 발생함

### 4. 트위터 스노우 플레이크 접근법

- 생성해야하는 ID의 구조를 여러 절로 분할함

![image](https://github.com/user-attachments/assets/f627fb1b-655e-4abd-a92e-2619eb3a0ff3)


- 구성
    - 사인 비트 : 1비트를 할당. 음수와 양수를 구분하는데 사용
    - 타임스탬프 : 41비트를 할당. 기원 시각 이후로 몇밀리초가 경과했는지 나타내는 값
    - 데이터센터 ID : 5비트를 할당. 2^5 = 32개의 서버를 사용할 수 있음
    - 서버 ID : 5비트 할당. 데이터 센터당 32개 서버를 사용할 수 있음
    - 일련번호 : 12비트를 할당. 각 서버에서는 ID를 생성할 때마다 일련번호를 1만큼 증가시킴. 이 값은 1밀리초가 경과할 때마다 0으로 최고하됨
- 데이터 센터 ID와 서버 ID는 시스템이 시작될때 결정되며, 일반적으로 시스템 운영중에는 바뀌지 않음
- 타임스탬프나 일련번호 ID는 생성기가 돌고 있는 중에 만들어지는 값
- 타임스탬프
    - 시간에 흐름에 따라 점점 큰 값을 가지게 되므로, ID는 시간순으로 정렬될 것임
        
        ![image](https://github.com/user-attachments/assets/8dcee9aa-fb82-48d9-b398-c6c983625088)

        
    - ID구조를 따르는 값의 이진 표현 형태로부터 UTC 시각을 추출해내는 예제이며, 이를 역으로 이용하면 어떤 UTC 시각도 상술한 타임스탬프 값으로 변환할 수 있음
    - 41비트로 표현할 수 있는 타임스탬프의 최댓값은 대략 69년임
    - 69년이 지나면, 기원 시각을 바꾸거나 ID 체계를 다른 것으로 이전해야함
- 일련번호
    - 12비트이므로, 4096개의 값을 가질 수 있음. 어떤 서버가 같은 밀리초동안 하나 이상의 ID를 만들어낸 경우에만 0보다 큰 값을 갖게됨

### 추가적으로 생각해 볼 내용들

1. 시계 동기화 : 하나의 서버가 여러 코어에서 실행될 경우나 여러 서버가 물리적으로 독립된 여러 장비에서 실행되는 경우에 유효하지 않을 수 있음. 시계 동기화를 해서 이문제를 해결해야하며, NTP는 이 문제를 해결하는 가장 보편적인 수단임
2. 각 섹션의 길이 최적화 : 동시성이 낮고 수명이 긴 애플리케이션이라면 일련번호 절의 길이를 줄이고, 타임스탬프 절의 길이를 늘리는 것이 효과적일 수 있음
3. 고가용성 : ID 생성기는 필수 불가결 컴포넌트이므로 아주 높은 가용성을 제공해야함
